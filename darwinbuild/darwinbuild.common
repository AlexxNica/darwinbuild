#!/bin/sh
#
# Copyright (c) 2005, Apple Computer, Inc. All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer. 
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution. 
# 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
#     its contributors may be used to endorse or promote products derived
#     from this software without specific prior written permission. 
# 
# THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.


###
### Given a list of filenames, this function will
### find the largest number after the '~' and return
### its value. Used to calculate a non-conflicting build number.
###
function GetBuildVersion() {
	local maxbuild="0"
	if [ $# -eq 0 ]; then
		echo ""
		return 0
	fi
	for X in $* ; do
		# Grab the numeric portion after the '~'
		build=$(echo $X | sed -e 's/^.*~\([0-9]*\)$/\1/')
		# If the regex fails, it somtimes prints the same line
		if [ "$build" != "$X" -a "$build" != "" ]; then
			# [ seems to things on the left of the -a, 
			# so do this in a different statement to avoid
			# errors about non-numeric values of $build
			if [ "$build" -gt "$maxbuild" ]; then
				maxbuild="$build"
			fi
		fi
	done
	echo $maxbuild
}

###
### Trap calls to ditto since it is only available on Mac OS X
### Warning: only supports the directory-to-directory form
function ditto() {
	local srcdir="$1"
	local dstdir="$2"
	if [ -x /usr/bin/ditto ]; then
		/usr/bin/ditto "$srcdir" "$dstdir"
	else
		tar c -C "$srcdir" . | tar xf - -C "$dstdir"
	fi
}

###
### Download a .tar.gz file
###
function Download() {
	local destination="$1"
	local filename="$2"
	local master_sites="$3"

	### Skip the .tar.gz download if an extracted version exists
	extracted=$(basename "$filename" .tar.gz)
	if [ -d "$destination/$extracted" ]; then
		echo "Found $extracted in $destination"
		return
	fi
	
	###
	### Download the sources,
	###
	for master_site in $master_sites ;
	do
		if [ ! -f "$destination/$filename" ]; then
			mkdir -p "$destination"
			echo "Attempting to download $master_site/$filename ..."
			curl --fail \
				--silent \
				--continue-at - \
				--output "$destination/.tmp.${filename}" \
				--url "$master_site/$filename"
			if [ "$?" == "0" ]; then
				mv "$destination/.tmp.${filename}" "$destination/$filename"
				echo "Download complete"
				break
			fi
		else
			echo "Found $filename in $destination"
			break
		fi
	done
}

###
### Installs a root into the BuildRoot. Mediates between
### receipts, pre-built roots, and self-built roots, so that
### the build root is "up to date"
### Relies on the DARWIN_BUILDROOT and CACHEDIR and DARWINXREF
### and dbfile globals.
###
function InstallRoot() {
	local BuildRoot="$1"
	local Project="$2"
	local DepsBuildArray="$3"

	local SelfBuiltRoot=""
	local InstallSelfBuiltRoot=0
	local InstallPreBuiltRoot=0

	shopt -s nullglob

	###
	### There will be duplication between the bash dependencies and the
	### project's dependencies.  Therefore don't install something that
	### has already been installed.  (Test for the presence of a receipt).
	###
	if [ -d "$DARWIN_BUILDROOT/Roots/$Project" ]; then
	    ProjectAndVersion=$($DARWINXREF $dbfile version "$Project")
	    bv=$(GetBuildVersion $DARWIN_BUILDROOT/Roots/$Project/$ProjectAndVersion.root*)
	    if [ -n "$bv" ]; then
		SelfBuiltRoot="$DARWIN_BUILDROOT/Roots/$Project/$ProjectAndVersion.root~$bv"
	    fi
	fi

	CheckForReceipt "$BuildRoot" "$Project" "root"
	if [ $? -eq 0 ]; then
	    # receipt is present. But do we have a newer local build?
	    CheckIfNewerThanReceipt "$BuildRoot" "$Project" "root" "$SelfBuiltRoot"
	    if [ $? -eq 0 ]; then
		# we're newer. Load us
		InstallSelfBuiltRoot=1
	    fi
	else
	    # there wasn't a receipt. but if we have a self-built root, we should use it
	    if [ -n "$SelfBuiltRoot" ]; then
		InstallSelfBuiltRoot=1
	    else
		InstallPreBuiltRoot=1
	    fi
	fi

	# install a self-built root, or a prebuilt root, or nothing
	if [ $InstallSelfBuiltRoot -eq 1 ]; then
	    echo "Copying $Project from $SelfBuiltRoot ..."
	    ditto "$SelfBuiltRoot" "$BuildRoot"
	    "$DARWINXREF" register "$Project" "$SelfBuiltRoot"  > /dev/null
	    TouchReceipt "$BuildRoot" "$Project" "root"
	    return 0
	elif [ $InstallPreBuiltRoot -eq 1 ]; then
	    # install a pre-built root, using the depsbuilds array, in preference order
	    for dbuild in $DepsBuildArray; do
	    	sites=$($DARWINXREF $dbfile -b $dbuild binary_sites | while read a; do echo "$a/$dbuild"; done)
		Download "$CACHEDIR/Roots/$dbuild" \
			"$Project.root.tar.gz" \
		    	"$sites"
		if [ -f $CACHEDIR/Roots/$dbuild/$Project.root.tar.gz ]; then
			cd "$BuildRoot"
			tar xzf $CACHEDIR/Roots/$dbuild/$Project.root.tar.gz
			if [ $? -eq 0 ]; then
				tar tzf $CACHEDIR/Roots/$dbuild/$Project.root.tar.gz | \
				    "$DARWINXREF" register -stdin "$Project" "$BuildRoot" \
				    > /dev/null
				echo | CreateReceipt "$BuildRoot" "$Project" "root" \
				    "$CACHEDIR/Roots/$dbuild/$Project.root.tar.gz"
				return 0
			fi
		fi

		# if we didn't find the root for this build, keep looking in the next build	     
	    done
	    # we look through all DepsBuildArray and couldn't actually install anything
	    return 1
	fi

	# we had a receipt, so nothing was request
	return 0
}

###
### Installs a headers root into the BuildRoot.  Checks for a
### receipt file to avoid duplicate installs.  Falls back on
### InstallRoot if no headers root is available.
### Relies on the DARWIN_BUILDROOT environment variable.
###
function InstallHeaders() {
	local BuildRoot="$1"
	local X="$2"
	local depsbuilds="$3"
	local receipts="$BuildRoot/usr/local/darwinbuild/receipts"

	shopt -s nullglob

	if [ ! -e "$receipts/$X.hdrs" -a ! -e "$receipts/$X" ]; then
	bv=$(GetBuildVersion $DARWIN_BUILDROOT/Headers/${X/-*}/$X.hdrs*)
	if [ -d $DARWIN_BUILDROOT/Headers/${X/-*}/$X.hdrs~$bv ]; then
		echo "Copying $X ..."
		ditto $DARWIN_BUILDROOT/Headers/${X/-*}/$X.hdrs~$bv $BuildRoot
		"$DARWINXREF" register "$X" $DARWIN_BUILDROOT/Headers/${X/-*}/$X.hdrs~$bv  > /dev/null
	else

	    # install a pre-built root, using the depsbuilds array, in preference order
	    for dbuild in $depsbuilds; do
	    	sites=$($DARWINXREF $dbfile -b $dbuild binary_sites | while read a; do echo "$a/$dbuild"; done)
		Download "$CACHEDIR/Headers/$dbuild" \
			"$X.hdrs.tar.gz" \
		    	"$sites"
		if [ -f $CACHEDIR/Headers/$dbuild/$X.hdrs.tar.gz ]; then
			cd "$BuildRoot"
			tar xzf $CACHEDIR/Headers/$dbuild/$X.hdrs.tar.gz
			if [ "$?" == "0" ]; then
				tar tzf $CACHEDIR/Headers/$dbuild/$X.hdrs.tar.gz | \
				    "$DARWINXREF" register -stdin "$X" "$BuildRoot" \
				    > /dev/null
				SHA1=$(openssl dgst -sha1 < $CACHEDIR/Headers/$dbuild/$X.hdrs.tar.gz)
				touch "$receipts/$SHA1"
				ln -sf "$SHA1" "$receipts/$X"
				break
			fi
		else
		    InstallRoot "$BuildRoot" "$X" "$depsbuilds"
		fi

		# XXX some may think this is buggy. If you fail to find
		# a header root for the first build, normal roots
		# are searched for along the build chain. Secondary
		# builds are never consulted for header roots

		# If InstallRoot worked, stop searching
		if [ -e "$receipts/$X" ]; then
		    break
		fi
	    done
	fi
	fi
}

RECEIPTDIR=/usr/local/darwinbuild/receipts

###
# For the given project and root type ("root" or "hdrs"), see if
# a receipt is present in the build root
function CheckForReceipt() {
    local BuildRoot="$1"
    local Project="$2"
    local RootType=".$3"
    local receipts="$BuildRoot/$RECEIPTDIR"

    if [ "$RootType" = ".root" ]; then
	RootType=""
    fi

    if [ -e "$receipts/$Project$RootType" ]; then
	return 0 # success
    else
	return 1
    fi
}

###
# For the given project and root type ("root" or "hdrs"), touch the
# a receipt so that it's timestamp is current
function TouchReceipt() {
    local BuildRoot="$1"
    local Project="$2"
    local RootType=".$3"
    local receipts="$BuildRoot/$RECEIPTDIR"

    if [ "$RootType" = ".root" ]; then
	RootType=""
    fi

    if [ -e "$receipts/$Project$RootType" ]; then
	touch "$receipts/$Project$RootType"
	return 0 # success
    else
	return 1
    fi
}

###
# For the given project and root type ("root" or "hdrs"), see if
# a receipt is present and newer than another filesystem object.
# By definition, something is newer than a non-existent receipt
# If CmpDir is "", this will return false (1)
function CheckIfNewerThanReceipt() {
    local BuildRoot="$1"
    local Project="$2"
    local RootType=".$3"
    local CmpDir="$4"
    local receipts="$BuildRoot/$RECEIPTDIR"

    if [ "$RootType" = ".root" ]; then
	RootType=""
    fi

    if [ -e "$receipts/$Project$RootType" ]; then
	if [ "$CmpDir" -nt "$receipts/$Project$RootType" ]; then
	    return 0
	else
	    return 1
	fi
    else
	return 0
    fi
}



###
# For the given project and root type ("root" or "hdrs"), take
# a receipt specification on stdin. In order to uniquely identify
# the receipt, a hash is stored of the receipt contents, or
# an optional hash source. The latter would be used to
# hash a pre-built tarball instead of the receipt
function CreateReceipt() {
    local BuildRoot="$1"
    local Project="$2"
    local RootType=".$3"
    local HashSource="$4"

    local receipts="$BuildRoot/$RECEIPTDIR"
    local TmpFile=$(mktemp -t "$Project")
    local Hash=""

    if [ "$RootType" = ".root" ]; then
	RootType=""
    fi

    mkdir -p "$receipts"

    # consume stdin
    cat > "$TmpFile"

    if [ -z "$HashSource" ]; then
	if [ ! -r "$HashSource" ]; then
	    echo "ERROR: Could not access $HashSource" 1>&2
	    exit 1
	fi
	Hash=$(openssl dgst -sha1 < "$HashSource")
    else
	Hash=$(openssl dgst -sha1 < "$TmpFile")
    fi

    cp "$TmpFile" "$receipts/$Hash"
    ln -sf "$Hash" "$receipts/$Project$RootType"
    return 0
}

